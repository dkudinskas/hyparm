APP_NAME := hypervisor

# Don't use built-in rules and variables for subsequent invocations of make.
# For makefile debugging, add: --warn-undefined-variables
MAKEFLAGS += -rR --no-print-directory

SOURCE_PATH  := src
SCRIPT_PATH  := scripts
OUTPUT_PATH  := build

VPATH        :=

HOSTCC       := gcc

HOSTCFLAGS   := -O2 -fomit-frame-pointer -Wall
HOSTCPPFLAGS :=


CC            = $(CROSS_COMPILE)gcc
AS            = $(CROSS_COMPILE)as
LD            = $(CROSS_COMPILE)ld
OBJCOPY       = $(CROSS_COMPILE)objcopy
OBJDUMP       = $(CROSS_COMPILE)objdump

AFLAGS       := --fatal-warnings
CFLAGS       := -marm -mabi=aapcs-linux -mno-thumb-interwork -msoft-float \
                -O3 -ffreestanding -fno-common -fno-stack-protector \
                -Wall -Wextra -Wformat=2 -Winline -Wstrict-prototypes -Wwrite-strings \
                -Wno-empty-body -Wno-unused-label -Wno-unused-parameter \
                -Werror=implicit-function-declaration
CPPFLAGS     := -iquote $(SOURCE_PATH) -nostdinc
LDFLAGS      := --error-unresolved-symbols
OBJDUMPFLAGS := -M reg-names-std


CLEAN_GOALS  := clean clean_% distclean
CONFIG_GOALS := %config
HELP_GOALS   := help

# List of all goals for which no dependency files will be generated and no build goals will be included.
# As %_GOALS variables may change later, delay their expansion.
NO_BUILD_GOALS = $(CLEAN_GOALS) $(CONFIG_GOALS) $(HELP_GOALS)


# Do not allow cleaning and doing anything else at once; in the current setup this would cause dependency tracking to be disabled.
# Fixing this issue is far harder than using "make clean && make".
ifneq ($(filter $(CLEAN_GOALS), $(MAKECMDGOALS)),)
  ifneq ($(filter-out $(CLEAN_GOALS), $(MAKECMDGOALS)),)
    $(error The following goals must be specified separately: $(filter $(CLEAN_GOALS), $(MAKECMDGOALS)))
  endif
endif

# For the same reason, do not allow updates to the configuration file to interfere with the build process.
ifneq ($(filter $(CONFIG_GOALS), $(MAKECMDGOALS)),)
  ifneq ($(filter-out $(CONFIG_GOALS), $(MAKECMDGOALS)),)
    $(error The following goals must be specified separately: $(filter $(CONFIG_GOALS), $(MAKECMDGOALS)))
  endif
endif

# And also ... let help come on its own. Why on earth would you combine it with something else anyway?
ifneq ($(filter $(HELP_GOALS), $(MAKECMDGOALS)),)
  ifneq ($(filter-out $(HELP_GOALS), $(MAKECMDGOALS)),)
    $(error The following goals must be specified separately: $(filter $(HELP_GOALS), $(MAKECMDGOALS)))
  endif
endif


.PHONY: all

all: _all


# Cancel implicit rules on makefiles (reduces output of make -d)
Makefile: ;
%/makefile.in: ;
%/makefile.mk: ;


# Include Kconfig makefile
include $(SCRIPT_PATH)/kconfig/makefile.mk


# Check if we are building
ifneq ($(filter $(NO_BUILD_GOALS),$(MAKECMDGOALS)),)

.PHONY: _all

_all: ;

else

.PHONY: _all

_all: $(KCONFIG_CONFIG) binary dump

$(KCONFIG_CONFIG):
	@echo 'MAKE     defconfig'
	@$(MAKE) defconfig

  # Include makefile generated by Kconfig
  include $(KCONFIG_AUTOCONFIG)

  # Configured cross-compiler toolchain overrides environment
  ifneq ($(CONFIG_CROSS_COMPILE),)
    CONFIG_CROSS_COMPILE := $(CONFIG_CROSS_COMPILE:"%"=%)
    ifneq ($(CONFIG_CROSS_COMPILE),)
      CROSS_COMPILE := $(CONFIG_CROSS_COMPILE:"%"=%)
    endif
  endif

  # Crash and burn if no cross compiler is configured
  ifeq ($(CROSS_COMPILE),)
    $(error You need to set up a cross compiler toolchain)
  endif


  AFLAGS-y :=
  CFLAGS-y :=
  CPPFLAGS-y := -imacros $(KCONFIG_AUTOHEADER)
  LDFLAGS-y :=

  ifeq ($(CONFIG_BUILD_SAVE_TEMPS),y)
    CFLAGS-y += -save-temps=obj
  else
    CFLAGS-y += -pipe
  endif

  # TODO AFLAGS IS A HACK
  AFLAGS-$(CONFIG_ARCH_V7_A) += --defsym CONFIG_ARCH_V7_A=1


  # TODO AFLAGS IS A HACK
  AFLAGS-$(CONFIG_ARCH_EXT_SECURITY) += --defsym CONFIG_ARCH_EXT_SECURITY=1


  AFLAGS-$(CONFIG_CPU_CORTEX_A8) += -mcpu=cortex-a8
  CFLAGS-$(CONFIG_CPU_CORTEX_A8) += -mcpu=cortex-a8

  AFLAGS-$(CONFIG_CPU_CORTEX_A9) += -mcpu=cortex-a9
  CFLAGS-$(CONFIG_CPU_CORTEX_A9) += -mcpu=cortex-a9


  # TODO AFLAGS IS A HACK
  AFLAGS-$(CONFIG_SOC_TI_OMAP_35XX) += --defsym CONFIG_SOC_TI_OMAP_35XX=1


  LDFLAGS-$(CONFIG_SOC_TI_OMAP_3530) += -T $(SCRIPT_PATH)/omap3530.lds


  AFLAGS-$(CONFIG_THUMB2) += --defsym CONFIG_THUMB2=1


  CFLAGS-$(CONFIG_DEBUG)  += -ggdb3
  #-fstack-usage -Wframe-larger-than=256
  LDFLAGS-$(CONFIG_DEBUG) += -Map $(OUTPUT_PATH)/$(APP_NAME).map --cref
  OBJDUMPFLAGS-$(CONFIG_DEBUG) += -lS

  # TODO AFLAGS IS A HACK
  AFLAGS-$(CONFIG_EMERGENCY_EXCEPTION_VECTOR) += --defsym CONFIG_EMERGENCY_EXCEPTION_VECTOR=1

  AFLAGS   += $(AFLAGS-y)
  CFLAGS   += $(CFLAGS-y)
  CPPFLAGS += $(CPPFLAGS-y)
  LDFLAGS  += $(LDFLAGS-y)
  OBJDUMPFLAGS += $(OBJDUMPFLAGS-y)

endif # ifneq ($(filter $(NO_BUILD_GOALS),$(MAKECMDGOALS)),)


HYPARM_DIRS-y := common cpuArch drivers/beagle exceptions guestManager instructionEmu linuxBoot memoryManager vm/omap35xx

# Guest support
HYPARM_DIRS-$(CONFIG_GUEST_FREERTOS) += rtosBoot

# Debugging
HYPARM_DIRS-$(CONFIG_MMC) += io io/fs

# Hacks
HYPARM_DIRS-$(CONFIG_CLI) += cli

HYPARM_SRCS_C-y := main.c
HYPARM_SRCS_S-y := startup.s


# Include all makefile.mk files from HYPARM_DIRS-y
include $(foreach DIR, $(HYPARM_DIRS-y), $(SOURCE_PATH)/$(DIR)/makefile.mk)


HYPARM_DEPS   := $(foreach SRC, $(HYPARM_SRCS_C-y), $(SOURCE_PATH)/$(SRC).d)

HYPARM_OBJS_C := $(foreach SRC, $(HYPARM_SRCS_C-y), $(SOURCE_PATH)/$(SRC).o)
HYPARM_OBJS_S := $(foreach SRC, $(HYPARM_SRCS_S-y), $(SOURCE_PATH)/$(SRC).o)
HYPARM_OBJS   := $(HYPARM_OBJS_C) $(HYPARM_OBJS_S)


# Check if we are building
ifeq ($(filter $(NO_BUILD_GOALS),$(MAKECMDGOALS)),)

  # Include automatically generated dependency files.
  -include $(HYPARM_DEPS)


.PHONY: binary dump

binary: $(OUTPUT_PATH)/$(APP_NAME).bin

dump: $(OUTPUT_PATH)/$(APP_NAME).dump


$(OUTPUT_PATH)/$(APP_NAME).dump: $(OUTPUT_PATH)/$(APP_NAME).elf
	@echo 'OBJDUMP  $@'
	@$(OBJDUMP) -d $(OBJDUMPFLAGS) $< > $@

$(OUTPUT_PATH)/$(APP_NAME).bin: $(OUTPUT_PATH)/$(APP_NAME).elf
	@echo 'OBJCOPY  $@'
	@$(OBJCOPY) -O binary $< $@

$(OUTPUT_PATH)/$(APP_NAME).elf: $(HYPARM_OBJS) $(KCONFIG_CONFIG)
	@echo 'LD       $@'
	@$(LD) -o $@ $(LDFLAGS) $(filter-out $(KCONFIG_CONFIG), $+)


$(SOURCE_PATH)/%.c.d: $(SOURCE_PATH)/%.c $(KCONFIG_OK)
ifneq ($(VERBOSE),)
	@echo 'DEP      $<'
endif
	@$(CC) -M $(CPPFLAGS) -MP -MT $(patsubst %.c,%.c.o,$<) $< > $@.$$$$ && \
	sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' < $@.$$$$ > $@ && \
	rm $@.$$$$

$(SOURCE_PATH)/%.c.o: $(SOURCE_PATH)/%.c
	@echo 'CC       $<'
	@$(CC) $(CFLAGS) $(CPPFLAGS) -c -o $@ $<

$(SOURCE_PATH)/%.s.o: $(SOURCE_PATH)/%.s $(KCONFIG_CONFIG)
	@echo 'AS       $<'
	@$(AS) $(AFLAGS) -o $@ $<

endif # ifeq ($(filter $(NO_BUILD_GOALS)),)


.PHONY: clean distclean

clean:
	@find $(SOURCE_PATH) -name '*.c.[dis]' -exec rm {} +
	@find $(SOURCE_PATH) -name '*.c.d.*' -exec rm {} +
	@find $(SOURCE_PATH) -name '*.o' -exec rm {} +
	@rm $(KCONFIG_AUTOCONFIG) $(KCONFIG_AUTOHEADER) $(KCONFIG_OK) \
	  $(OUTPUT_PATH)/$(APP_NAME).{elf,map,bin,dump} 2> /dev/null || :

distclean: clean clean_kconfig
	@rm -r $(KCONFIG_CONFIG) $(KCONFIG_CONFIG).old $(OUTPUT_PATH) 2> /dev/null || :


.PHONY: help

help:
	@echo 'Cleaning targets:'
	@echo '  clean          Remove files generated during hypervisor build'
	@echo '  clean_kconfig  Remove files generated during KConfig build'
	@echo '  distclean      Remove all generated files including $(KCONFIG_CONFIG)'
	@echo
	@echo 'Configuration targets:'
	@echo '  config         Create or update $(KCONFIG_CONFIG)'
	@echo '  defconfig      Create $(KCONFIG_CONFIG) with defaults from $(SCRIPT_PATH)/defconfig'
	@echo
	@echo 'Build targets:'
	@echo '  all            Build all targets marked with [*]'
	@echo '* binary         Build $(APP_NAME).bin'
	@echo '* dump           Build $(APP_NAME).dump'
	@echo
	@echo 'Some influential environment variables:'
	@echo '  CROSS_COMPILE  Cross-compiler toolchain prefix'
	@echo
	@echo 'Values for these variables specified in $(KCONFIG_CONFIG) override environment values.'

